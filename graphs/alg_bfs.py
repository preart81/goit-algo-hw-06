"""Пошук у ширину (BFS)

Пошук у ширину (BFS) відрізняється від DFS тим, що він відвідує всі вершини
на певному рівні перед тим, як перейти до наступного рівня. BFS є корисним для
знаходження найкоротшого шляху в незважених графах та при розв'язку завдань, які
вимагають відвідування вершин у порядку, віддаленому від вихідної вершини."""

from collections import deque


def bfs_iterative(graph, start_vertex, end_vertex=None) -> list:
    """
    Ітеративний пошук в ширину BFS

    параметри:
        graph: dict
            граф;
        start: Any
            початкова вершина
    Повертає:
        visited - відвідані вершини в порядку відвідування.
    """
    # Ініціалізація порожньої множини для зберігання відвіданих вершин
    visited = list()
    # Ініціалізація черги з початковою вершиною
    queue = deque([start_vertex])

    # Поки черга не порожня, продовжуємо обхід
    while queue and end_vertex not in visited:
        # Вилучаємо першу вершину з черги
        vertex = queue.popleft()
        # Перевіряємо, чи була вершина відвідана раніше
        if vertex not in visited:
            # Якщо не була відвідана, друкуємо її
            # print(vertex, end=" ") # DEBUG
            # Додаємо вершину до множини відвіданих вершин
            visited.append(vertex)
            # Додаємо всіх невідвіданих сусідів вершини до кінця черги
            # Операція різниці множин вилучає вже відвідані вершини зі списку сусідів
            queue.extend(set(graph[vertex]) - set(visited))
    # Повертаємо множину відвіданих вершин після завершення обходу
    return visited


if __name__ == "__main__":
    # Представлення графа за допомогою списку суміжності
    graph = {
        "A": ["B", "C"],
        "B": ["A", "D", "E"],
        "C": ["A", "F"],
        "D": ["B"],
        "E": ["B", "F"],
        "F": ["C", "E"],
    }

    # Запуск алгоритму BFS
    print(f"{bfs_iterative(graph, 'A') = }")
